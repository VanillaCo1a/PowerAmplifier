C51 COMPILER V8.06   FFT                                                                   11/29/2018 19:11:54 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE FFT
OBJECT MODULE PLACED IN FFT.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE FFT.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include        "FFT.h"
   2          /********************************************************************/
   3          float pow   (float x, float y);   //计算x的y次幂
   4          float cos   (float val);
   5          float sin   (float val);
   6          struct compx       //定义复数结构体
   7          {
   8                  float real;        /*实部*/
   9                  float imag;        /*虚部*/
  10          };
  11          
  12          /******************************************************************* 
  13          函数原型：struct compx EE(struct compx a1,struct compx b2) 
  14          函数功能：对两个复数进行乘法运算
  15          输入参数：两个以联合体定义的复数a,b 
  16          输出参数：a和b的乘积，以联合体的形式输出
  17          *******************************************************************/
  18          struct compx EE(struct compx a1,struct compx b2)        //复数乘法
  19          {
  20   1              struct compx b3;
  21   1              b3.real=a1.real*b2.real-a1.imag*b2.imag;
  22   1              b3.imag=a1.real*b2.imag+a1.imag*b2.real;
  23   1              return(b3);
  24   1      }
  25          
  26          /***************************************************************** 
  27          FFT函数
  28          函数原型：void FFT(struct compx *xin,int N) 
  29          函数功能：对输入的复数组进行快速傅里叶变换（FFT）
  30          输入参数：xin[]数组，struct型
  31          *****************************************************************/ 
  32          void FFT(struct compx xin[],int N)                              
  33          {
  34   1              int f,m,nv2,nm1,i,k,j=1,l;
  35   1              struct compx v,w,t;
  36   1              int le,lei,ip;                          //FFT运算核，使用蝶形运算完成FFT运算
  37   1              float pi;
  38   1              nv2=N/2;                                        //变址运算，即把自然顺序变成倒位序，采用雷德算
  39   1              f=N;
  40   1              for(m=1;(f=f/2)!=1;m++){;}
  41   1              nm1=N-1;
  42   1              for(i=0;i<nm1;i++)          //倒序操作
  43   1              {
  44   2                      if(i<j)                                 //如果i<j,即进行变址
  45   2                      {
  46   3                              t=xin[j];
  47   3                              xin[j]=xin[i];
  48   3                              xin[i]=t;
  49   3                      }
  50   2                      k=nv2;                                  //求j的下一个倒位序     //k为倒序中相应位置的权值
  51   2                      while(k<j)
  52   2                      {
  53   3                              j=j-k;                          //把最高位变成0
  54   3                              k=k/2;                          //k/2，比较次高位，依次类推，逐个比较，直到某个位为0
  55   3                      }
C51 COMPILER V8.06   FFT                                                                   11/29/2018 19:11:54 PAGE 2   

  56   2                      j=j+k;                                  //把0改为1 
  57   2              }
  58   1               
  59   1              for(l=1;l<=m;l++)               //计算l的值，即计算蝶形级数
  60   1              {
  61   2                      le=pow(2,l);            //乘方
  62   2                      lei=le/2;
  63   2                      pi=3.14159265;          //给结构体赋值
  64   2                      v.real=1.0;                     //实部为正弦波FFT_N点采样，赋值为1
  65   2                      v.imag=0.0;                                     //虚部为0
  66   2                      w.real=cos(pi/lei);                     //旋转因子
  67   2                      w.imag=-sin(pi/lei);
  68   2                      
  69   2              for(j=1;j<=lei;j++)                             //控制蝶形运算的级数
  70   2                      {
  71   3                      for(i=j-1;i<N;i=i+le)                   //控制每级蝶形运算的次数
  72   3                              {
  73   4                                      ip=i+lei;                               //i，ip分别表示参加蝶形运算的两个节点
  74   4                                      t=EE(xin[ ip ],v);              //蝶形运算，详见公式
  75   4                                      xin[ ip ].real=xin[ i ].real-t.real;   
  76   4                                      xin[ ip ].imag=xin[ i ].imag-t.imag;
  77   4                                      xin[ i ].real=xin[ i ].real+t.real;
  78   4                                      xin[ i ].imag=xin[ i ].imag+t.imag;
  79   4                              }
  80   3                              v=EE(v,w); //改变系数，进行下一个蝶形运算  
  81   3                      }     
  82   2              }
  83   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1139    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      77
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
