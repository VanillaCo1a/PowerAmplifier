C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 1
OBJECT MODULE PLACED IN 1.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 1.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //电脑音量推荐设置为40%，手机及MP4等要高一些
   2          #include <STC12C5A60S2.h>
   3          #include<intrins.h>
   4          
   5          /********************************************************************/
   6          #define SAMPLE_NUM 128
   7          #define LOG 6
   8          #define TIME 2048          //中断
   9          #define FFT_OUT_MIN 0
  10          #define FFT_OUT_MAX     7       
  11          #define OFF L1=L2=L3=L4=L5=L6=L7=L8=L9=L10=L11=L12=L13=L14=L15=L16=L17=L18=L19=L20=L21=L22=L23=L24=1;
  12          #define ADC_POWER   0x80            //ADC power control bit 
  13          #define ADC_FLAG    0x10            //ADC complete flag 
  14          #define ADC_START   0x08            //ADC start control bit 
  15          //#define ADC_SPEEDLL 0x00            //420 clocks 
  16          //#define ADC_SPEEDL  0x20            //280 clocks 
  17          #define ADC_SPEEDH  0x40            //140 clocks 
  18          //#define ADC_SPEEDHH 0x60            //70 clocks 
  19          
  20          /********************************************************************/
  21          //采样存储序列表
  22          unsigned char code BRTable[SAMPLE_NUM] ={0, 64, 32, 96, 16, 80, 48, 112,
  23          8, 72, 40, 104, 24, 88, 56, 120,
  24          4, 68, 36, 100, 20, 84, 52, 116,
  25          12, 76, 44, 108, 28, 92, 60, 124,
  26          2, 66, 34, 98, 18, 82, 50, 114,
  27          10, 74, 42, 106, 26, 90, 58, 122,
  28          6, 70, 38, 102, 22, 86, 54, 118,
  29          14, 78, 46, 110, 30, 94, 62, 126,
  30          1, 65, 33, 97, 17, 81, 49, 113,
  31          9, 73, 41, 105, 25, 89, 57, 121,
  32          5, 69, 37, 101, 21, 85, 53, 117,
  33          13, 77, 45, 109, 29, 93, 61, 125,
  34          3, 67, 35, 99, 19, 83, 51, 115,
  35          11, 75, 43, 107, 27, 91, 59, 123,
  36          7, 71, 39, 103, 23, 87, 55, 119,
  37          15, 79, 47, 111, 31, 95, 63, 127};
  38          char code sin_tabb[SAMPLE_NUM] = {0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 59, 65, 70, 75, 80, 85, 89, 94, 98
             -, 102, 
  39          
  40          105, 108, 112, 114, 117, 119, 121, 123, 124, 125, 126, 126, 126, 126, 126, 125, 124, 123, 121, 119, 117, 1
             -14, 112, 
  41          
  42          108, 105, 102, 98, 94, 89, 85, 80, 75, 70, 65, 59, 54, 48, 42, 36, 30, 24, 18, 12, 6, 0, -6, -12, -18, -24
             -, -30, 
  43          
  44          -36, -42, -48, -54, -59, -65, -70, -75, -80, -85, -89, -94, -98, -102, -105, -108, -112, -114, -117, -119,
             - -121, 
  45          
  46          -123, -124, -125, -126, -126, -126, -126, -126, -125, -124, -123, -121, -119, -117, -114, -112, -108, -105
             -, -102, 
  47          
  48          -98, -94, -89, -85, -80, -75, -70, -65, -59, -54, -48, -42, -36, -30, -24, -18, -12, -6};                 
             -        
  49          char code cos_tabb[SAMPLE_NUM] = {127, 126, 126, 125, 124, 123, 121, 119, 117, 114, 112, 108, 105, 102, 98
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 2   

             -, 94, 
  50          
  51          89, 85, 80, 75, 70, 65, 59, 54, 48, 42, 36, 30, 24, 18, 12, 6, 0, -6, -12, -18, -24, -30, -36, -42, -48, -
             -54, -59, 
  52          
  53          -65, -70, -75, -80, -85, -89, -94, -98, -102, -105, -108, -112, -114, -117, -119, -121, -123, -124, -125, 
             --126, -
  54          
  55          126, -126, -126, -126, -125, -124, -123, -121, -119, -117, -114, -112, -108, -105, -102, -98, -94, -89, -8
             -5, -80, 
  56          
  57          -75, -70, -65, -59, -54, -48, -42, -36, -30, -24, -18, -12, -6, 0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 59, 
             -65, 70, 
  58          
  59          75, 80, 85, 89, 94, 98, 102, 105, 108, 112, 114, 117, 119, 121, 123, 124, 125, 126, 126};
  60          xdata unsigned char result[128];
  61          xdata unsigned char temp[128];
  62          xdata unsigned char num[128];
  63          unsigned char anum,timernum,timernum2,lednum3,Ltime,t;//用于分离
  64          unsigned char lednum[]={0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,0xff};//0-7的显示数组  P2组控制
  65          int xdata FftReal[SAMPLE_NUM];
  66          int xdata FftImage[SAMPLE_NUM];
  67          
  68          unsigned char code musicdisplay[]={
  69                  0x00,0x00,
  70                  0xFE,0x40,0x30,0x40,0xFE,0x00, // -M-
  71                  0xFC,0x02,0x02,0x02,0xFC,0x00, // -U-
  72                  0x64,0x92,0x92,0x92,0x4C,0x00, // -S-
  73                  0x00,0x82,0xFE,0x82,0x00,0x00, // -I-
  74                  0x7C,0x82,0x82,0x82,0x44,0x00, // -C-
  75                  0x00,0x00,0x00,
  76                  0xFE,0x82,0x82,0x82,0x7C,0x00, // -D-
  77                  0x00,0x82,0xFE,0x82,0x00,0x00, // -I-
  78                  0x64,0x92,0x92,0x92,0x4C,0x00, // -S-
  79                  0xFE,0x90,0x90,0x90,0x60,0x00, // -P-
  80                  0xFE,0x02,0x02,0x02,0x02,0x00, // -L-
  81                  0x3E,0x48,0x88,0x48,0x3E,0x00, // -A-
  82                  0xC0,0x20,0x1E,0x20,0xC0,0x00, // -Y-
  83                  0x00,0x00,0x00,0x00,0x00,0x00,
  84                  0x00,0x00,0x00,0x00,0x00,0x00,
  85                  0x00,0x00,0x00,0x00,0x00,0x00,
  86                  0x00,0x00,0x00,0x00,0x00,0x00,
  87                  0x00,0x00,0x00,0x00,0x00,0x00};
  88          /********************************************************************/
  89          #define LED P2
  90          #define pwm 9
  91          
  92          sbit L24=P3^2;
  93          sbit L23=P3^1;
  94          sbit L22=P3^0;
  95          sbit L21=P4^7;
  96          sbit L20=P1^7;
  97          sbit L19=P1^6;
  98          sbit L18=P1^5;
  99          sbit L17=P1^4;
 100          sbit L16=P3^3;
 101          sbit L15=P3^4;
 102          sbit L14=P3^5;
 103          sbit L13=P3^6;
 104          sbit L12=P3^7;
 105          sbit L11=P0^2;
 106          sbit L10=P0^1;
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 3   

 107          sbit L9=P0^0;
 108          sbit L8=P0^3;
 109          sbit L7=P0^4;
 110          sbit L6=P0^5;
 111          sbit L5=P0^6;
 112          sbit L4=P0^7;
 113          sbit L3=P4^6;
 114          sbit L2=P4^5;
 115          sbit L1=P4^4;
 116          /********************************************************************/
 117          void delay(unsigned char a)
 118          { 
 119   1              unsigned int i;
 120   1              while(--a)
 121   1                      for(i=0;i<50;i++);                                 
 122   1      }
 123          /********************************************************************/
 124          void off()
 125          { 
 126   1              LED = 0x00;
 127   1              OFF
 128   1      //      delay(10-pwm); 
 129   1      }
 130          /********************************************************************/
 131          void display(unsigned char i,unsigned char dat)
 132          {
 133   1              P2=dat;
 134   1              switch(i)
 135   1              {
 136   2                      case 1:L1=0;break;
 137   2                      case 2:L2=0;break;
 138   2                      case 3:L3=0;break;
 139   2                      case 4:L4=0;break;
 140   2                      case 5:L5=0;break;
 141   2                      case 6:L6=0;break;
 142   2                      case 7:L7=0;break;
 143   2                      case 8:L8=0;break;
 144   2                      case 9:L9=0;break;
 145   2                      case 10:L10=0;break;
 146   2                      case 11:L11=0;break;
 147   2                      case 12:L12=0;break;
 148   2                      case 13:L13=0;break;
 149   2                      case 14:L14=0;break;
 150   2                      case 15:L15=0;break;
 151   2                      case 16:L16=0;break;
 152   2                      case 17:L17=0;break;
 153   2                      case 18:L18=0;break;
 154   2                      case 19:L19=0;break;
 155   2                      case 20:L20=0;break;
 156   2                      case 21:L21=0;break;
 157   2                      case 22:L22=0;break;
 158   2                      case 23:L23=0;break;
 159   2                      case 24:L24=0;break;
 160   2              }
 161   1              delay(pwm);
 162   1              off();
 163   1      }
 164          /********************************************************************/
 165          void show_musicdisplay()
 166          {
 167   1              unsigned char a,b,c;
 168   1              for(c=0;c<80;c++)
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 4   

 169   1                      for(b=12;b>0;b--)
 170   1                              for(a=1;a<25;a++)
 171   1                                      display(a,musicdisplay[a-1+c]);
 172   1      }
 173          /********************************************************************/             
 174          void FFT_process()                        //下落迟滞
 175          {
 176   1              unsigned char i;
 177   1              for(i=0;i<24;i++)
 178   1              {       
 179   2                      if(result[i] < temp[i])
 180   2                      {
 181   3                              num[i]++;
 182   3                              if(num[i] == 1)
 183   3                              {
 184   4                                      if(temp[0]==0&&temp[1]==0&&temp[2]==0&&temp[3]==0&&temp[4]==0&&temp[5]==0&&temp[6]==0&&temp[7]==0&&tem
             -p[8]==0&&temp[9]==0&&temp[10]==0&&temp[11]==0&&temp[12]==0&&temp[13]==0&&temp[14]==0&&temp[15]==0&&temp[16]==0&&temp[17]
             -==0&&temp[18]==0&&temp[19]==0&&temp[20]==0&&temp[21]==0&&temp[22]==0&&temp[23]==0&&temp[24]==0);
 185   4                                      else
 186   4                                      {
 187   5                                              result[i] = --temp[i];
 188   5                                              num[i] = 0;
 189   5                                      }
 190   4                              }
 191   3                      }
 192   2                      else
 193   2                              num[i] = 0;             
 194   2              }
 195   1      }
 196          /********************************************************************/
 197          void disp()
 198          {
 199   1      //      unsigned char i,j,buff;
 200   1              timernum++;
 201   1              if(timernum == 25) 
 202   1                      timernum = 1;
 203   1              OFF
 204   1              FFT_process();
 205   1              /*for(i=0;i<16;i++)
 206   1                      for(j=i+1;j<16;j++)
 207   1                              if(result[j] > result[i])
 208   1                              {
 209   1                                      buff = result[i];
 210   1                                      result[i] = result[j];
 211   1                                      result[j] = buff;
 212   1                              }*/                                       
 213   1              switch(timernum)
 214   1              {
 215   2                      case 1:anum = result[0];L1=0;break;
 216   2                      case 2:anum = result[1];L2=0;break;
 217   2                      case 3:anum = result[2];L3=0;break;
 218   2                      case 4:anum = result[3];L4=0;break;
 219   2                      case 5:anum = result[4];L5=0;break;
 220   2                      case 6:anum = result[5];L6=0;break;
 221   2                      case 7:anum = result[6];L7=0;break;
 222   2                      case 8:anum = result[7];L8=0;break;
 223   2                      case 9:anum = result[8];L9=0;break;
 224   2                      case 10:anum = result[9];L10=0;break;
 225   2                      case 11:anum = result[10];L11=0;break;
 226   2                      case 12:anum = result[11];L12=0;break;
 227   2                      case 13:anum = result[12];L13=0;break;
 228   2                      case 14:anum = result[13];L14=0;break;
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 5   

 229   2                      case 15:anum = result[14];L15=0;break;
 230   2                      case 16:anum = result[15];L16=0;break;
 231   2                      case 17:anum = result[16];L17=0;break;
 232   2                      case 18:anum = result[17];L18=0;break;
 233   2                      case 19:anum = result[18];L19=0;break;
 234   2                      case 20:anum = result[19];L20=0;break;
 235   2                      case 21:anum = result[20];L21=0;break;
 236   2                      case 22:anum = result[21];L22=0;break;
 237   2                      case 23:anum = result[22];L23=0;break;
 238   2                      case 24:anum = result[23];L24=0;break;
 239   2              }
 240   1              if(anum >= 8)
 241   1                      anum = FFT_OUT_MAX;
 242   1              LED = lednum[anum];
 243   1      }
 244          /********************************************************************/
 245          void ADC_init()
 246          {
 247   1              P1ASF = 0x01;                   //Open 8 channels ADC function 
 248   1          ADC_RES = 0;                    //Clear previous result 
 249   1              ADC_RESL= 0;
 250   1          ADC_CONTR = ADC_POWER | ADC_SPEEDH; 
 251   1          delay(5);                       //ADC power-on and delay      
 252   1      }
 253          /********************************************************************/
 254          float ADC_read()
 255          {
 256   1      //delay(10);    
 257   1          ADC_CONTR = ADC_POWER | ADC_SPEEDH  | ADC_START; 
 258   1          _nop_();                        //至少要延时4个时钟周期
 259   1          _nop_(); 
 260   1          _nop_(); 
 261   1          _nop_();
 262   1              _nop_(); 
 263   1          while (!(ADC_CONTR & ADC_FLAG));//Wait complete flag 
 264   1          ADC_CONTR &= ~ADC_FLAG;         //关闭ADC 
 265   1          return (ADC_RES*4+ADC_RESL);                 //Return ADC result
 266   1      }
 267          /********************************************************************/
 268          short sqrt_16(unsigned long M)   
 269          {
 270   1          unsigned int N,i;
 271   1          unsigned long tmp,ttp; 
 272   1          if( M == 0 )             
 273   1              return 0;   
 274   1          N = 0;  
 275   1          tmp = (M >> 30);        
 276   1          M <<= 2;
 277   1          if( tmp > 1 )            
 278   1          {
 279   2              N++;               
 280   2              tmp -= N;
 281   2          }   
 282   1          for( i=15; i>0; i-- )   
 283   1          {
 284   2              N <<= 1;                  
 285   2              tmp <<= 2;
 286   2              tmp += (M >> 30);          
 287   2              ttp = N;
 288   2              ttp = (ttp<<1)+1;        
 289   2              M <<= 2;
 290   2              if( tmp >= ttp )    
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 6   

 291   2              {
 292   3                  tmp -= ttp;
 293   3                  N ++;
 294   3              }       
 295   2          }   
 296   1          return N;
 297   1      }
 298          /********************************************************************/
 299          void FFT()
 300          {
 301   1          register unsigned char i,bb,j,k,p;
 302   1          register short TR,TI,temp;
 303   1          unsigned long ulReal,ulImage;                             
 304   1              unsigned char max;
 305   1                                                                         
 306   1          for(i=0;i<SAMPLE_NUM;i++)    
 307   1          {
 308   2                      FftReal[BRTable[i]] = ADC_read();
 309   2              FftImage[i] = 0;
 310   2          }   
 311   1      
 312   1          for(i=1;i<=LOG;i++)                         
 313   1          { 
 314   2              bb=1;
 315   2              bb <<= (i-1);                                      
 316   2              for(j=0;j<=bb-1;j++)                            
 317   2              { 
 318   3                  p=1;
 319   3                  p <<= (LOG-i);           
 320   3                  p = p*j;
 321   3                  for(k=j;k<SAMPLE_NUM;k=k+2*bb)               
 322   3                  { 
 323   4                      TR=FftReal[k];TI=FftImage[k];temp=FftReal[k+bb];
 324   4                      FftReal[k]=FftReal[k]+((FftReal[k+bb]*cos_tabb[p])>>7)+((FftImage[k+bb]*sin_tabb[p])>>7);
 325   4                      FftImage[k]=FftImage[k] - ((FftReal[k+bb]*sin_tabb[p])>>7)+((FftImage[k+bb]*cos_tabb[p])>>
             -7);
 326   4                      FftReal[k+bb]=TR-((FftReal[k+bb]*cos_tabb[p])>>7)-((FftImage[k+bb]*sin_tabb[p])>>7);
 327   4                      FftImage[k+bb]=TI+((temp*sin_tabb[p])>>7)-((FftImage[k+bb]*cos_tabb[p])>>7); 
 328   4                      
 329   4                      FftReal[k] >>= 1;             
 330   4                      FftImage[k] >>= 1; 
 331   4                      FftReal[k+bb] >>= 1;                 
 332   4                      FftImage[k+bb] >>= 1;                                                                     
             -          
 333   4                  }  
 334   3              }
 335   2          }
 336   1      
 337   1         for(i=0;i<24;i++)
 338   1          {  
 339   2              ulReal = FftReal[i+1];
 340   2              ulReal *= ulReal;
 341   2              ulImage = FftImage[i+1];
 342   2              ulImage *= ulImage;       
 343   2              result[i] = sqrt_16(ulReal+ulImage);                                                      
 344   2                          
 345   2          }
 346   1      /*      for(i=0;i<17;i++)
 347   1          {
 348   1                      while(result[i] > FFT_OUT_MAX)
 349   1                      {
 350   1                      for(i=0;i<17;i++)
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 7   

 351   1                   {                  
 352   1                              result[i] =result[i] -1;      
 353   1                       } 
 354   1                  }
 355   1              }        */
 356   1              while(result[i] == FFT_OUT_MIN)
 357   1                      {
 358   2                      for(i=0;i<24;i++)
 359   2                   {                  
 360   3                              result[i] =result[i] +1;      
 361   3                       } 
 362   2                  }
 363   1              for(i=0;i<24;i++)
 364   1              {
 365   2                      if(result[i] > FFT_OUT_MAX)
 366   2                      {
 367   3                              result[i] = FFT_OUT_MAX;      
 368   3                              if(result[i] > max)
 369   3                      max = result[i];
 370   3                      } 
 371   2              }
 372   1              //局部增益      */      /*                      
 373   1                      /*if(max >= 4)          
 374   1                      for(i=1;i<24;i++)
 375   1                              if(result[i] >= 2)
 376   1                                      result[i]+=1;     */
 377   1                                                                       
 378   1      }
 379          /********************************************************************/             
 380          void init()
 381          {
 382   1              P2M0=0XFF;
 383   1              P2M1=0X00;
 384   1              P3M0=0XFF;
 385   1              P3M1=0X00;
 386   1              P1M0=0XFE;
 387   1              P1M1=0X01;
 388   1              P4SW=0x70;
 389   1      
 390   1              ADC_init();
 391   1              //AUXR |= 0x80;         //定时器时钟1T模式
 392   1              TMOD=0x01;
 393   1              TH0=(65535-TIME)/256;
 394   1              TL0=(65535-TIME)%256;
 395   1          EA=1;
 396   1              ET0=1;          
 397   1              show_musicdisplay();  
 398   1              TR0=1;
 399   1      }
 400          /********************************************************************/
 401          void main()
 402          {
 403   1              init();
 404   1          while(1)      
 405   1              FFT();
 406   1      }
 407          /********************************************************************/
 408          void timer0() interrupt 1
 409          {
 410   1              unsigned char i;
 411   1              t++;
 412   1              if(t == 24)
C51 COMPILER V9.01   1                                                                     02/17/2013 10:25:30 PAGE 8   

 413   1              {
 414   2                      for(i=0;i<24;i++)
 415   2                              temp[i] = result[i];
 416   2                      t = 0;
 417   2              }                                  
 418   1              disp();
 419   1              TH0=(65535-TIME)/256;   
 420   1              TL0=(65535-TIME)%256;
 421   1      }
 422          /********************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2562    ----
   CONSTANT SIZE    =    491    ----
   XDATA SIZE       =    896    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      34
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
