C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 12:01:51 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART0_APP
OBJECT MODULE PLACED IN UART0_app.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE UART0_app.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND
                    - TABS(2)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU Programme Demo ----------------------------*/
   5          /* --- Fax: 86-755-82944243 ----------------------------------------*/
   6          /* --- Tel: 86-755-82948412 ----------------------------------------*/
   7          /* --- Web: www.STCMCU.com -----------------------------------------*/
   8          /* If you want to use the program or the program referenced in the  */
   9          /* article, please specify in which data and procedures from STC    */
  10          /*------------------------------------------------------------------*/
  11          
  12          /*      本程序经过测试完全正常, 不提供电话技术支持, 如不能理解, 请自行补充相关基础.  */
  13          
  14          
  15          /*************  本程序功能说明  **************
  16          
  17            测试方法：
  18          
  19            根据您的主时钟和波特率修改"用户定义参数"里的相关定义，编译后下载到MCU。
  20          
  21            通过串口助手向MCU发送数据，MCU收到后原样返回。
  22          */
  23          
  24          
  25          /*************** 用户定义参数 *****************************/
  26          
  27          #define MAIN_Fosc   11059200L //define main clock
  28          
  29          #define Baudrate1   9600    //define the baudrate, 如果使用BRT做波特率发生器,则波特率跟串口2一样
  30                            //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  31          
  32          #define Baudrate2   19200   //define the baudrate2,
  33                            //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  34          
  35          #define   BUF_LENTH 128   //定义串口接收缓冲长度
  36          
  37          /**********************************************************/
  38          
  39          #include  <reg51.h>
  40          
  41          sfr AUXR1 = 0xA2;
  42          sfr AUXR = 0x8E;
  43          sfr S2CON = 0x9A; //12C5A60S2双串口系列
  44          sfr S2BUF = 0x9B; //12C5A60S2双串口系列
  45          sfr IE2   = 0xAF; //STC12C5A60S2系列
  46          sfr BRT   = 0x9C;
  47          
  48          unsigned char   uart1_wr;   //写指针
  49          unsigned char   uart1_rd;   //读指针
  50          unsigned char   xdata RX1_Buffer[BUF_LENTH];
  51          bit   B_TI;
  52          
  53          unsigned char   uart2_wr;   //写指针
  54          unsigned char   uart2_rd;   //读指针
C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 12:01:51 PAGE 2   

  55          unsigned char   xdata RX2_Buffer[BUF_LENTH];
  56          bit   B_TI2;
  57          
  58          
  59          /****************** 编译器自动生成，用户请勿修改 ************************************/
  60          
  61          #define T1_TimerReload  (256 - MAIN_Fosc / 192 / Baudrate1)     //Calculate the timer1 reload value at 12T mo
             -de
  62          #define BRT_Reload    (256 - MAIN_Fosc / 12 / 16 / Baudrate2)   //Calculate BRT reload value
  63          
  64          #define TimeOut1    (28800 / (unsigned long)Baudrate1 + 2)
  65          #define TimeOut2    (28800 / (unsigned long)Baudrate2 + 2)
  66          
  67          #define TI2       (S2CON & 0x02) != 0
  68          #define RI2       (S2CON & 0x01) != 0
  69          #define CLR_TI2()   S2CON &= ~0x02
  70          #define CLR_RI2()   S2CON &= ~0x01
  71          
  72          /**********************************************************/
  73          
  74          /******************** 本地函数声明 ***************/
  75          void  uart1_init(void);
  76          void  uart2_init(void);
  77          void  UART1_TxByte(unsigned char dat);
  78          void  UART2_TxByte(unsigned char dat);
  79          void  PrintString1(unsigned char code *puts);
  80          void  PrintString2(unsigned char code *puts);
  81          
  82          
  83          
  84          void  main(void)
  85          {
  86   1        uart1_rd = 0;
  87   1        uart1_wr = 0;
  88   1        uart2_rd = 0;
  89   1        uart2_wr = 0;
  90   1      
  91   1        AUXR |=  0x01;    //串口1使用独立波特率发生器, 波特率跟串口2一样
  92   1      //  AUXR1 |= (1<<4);  //将UART2从P1口切换到 RXD2--P1.2切换到P4.2   TXD2---P1.3切换到P4.3
  93   1        
  94   1        uart1_init();
  95   1        uart2_init();
  96   1        
  97   1        PrintString1("串口1测试程序");
  98   1        PrintString2("串口2测试程序");
  99   1        
 100   1        while(1)
 101   1        {
 102   2          
 103   2          
 104   2            PrintString1("串口1测试程序");
 105   2            PrintString2("串口2测试程序");
 106   2          if(uart1_rd != uart1_wr)  //串口0转发
 107   2          {
 108   3            UART1_TxByte(RX1_Buffer[uart1_rd]);
 109   3            if(++uart1_rd >= BUF_LENTH)   uart1_rd = 0;
 110   3          }
 111   2      
 112   2          if(uart2_rd != uart2_wr)  //串口2转发
 113   2          {
 114   3            UART2_TxByte(RX2_Buffer[uart2_rd]);
 115   3            if(++uart2_rd >= BUF_LENTH)   uart2_rd = 0;
C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 12:01:51 PAGE 3   

 116   3          }
 117   2        }
 118   1      }
 119          
 120          void  UART1_TxByte(unsigned char dat)
 121          {
 122   1        B_TI = 0;
 123   1        SBUF = dat;
 124   1        while(!B_TI);
 125   1        B_TI = 0;
 126   1      }
 127          
 128          void  UART2_TxByte(unsigned char dat)
 129          {
 130   1        B_TI2 = 0;
 131   1        S2BUF = dat;
 132   1        while(!B_TI2);
 133   1        B_TI2 = 0;
 134   1      }
 135          
 136          void PrintString1(unsigned char code *puts)   //发送一串字符串
 137          {
 138   1          for (; *puts != 0;  puts++)  UART1_TxByte(*puts);   //遇到停止符0结束
 139   1      }
 140          
 141          void PrintString2(unsigned char code *puts)   //发送一串字符串
 142          {
 143   1          for (; *puts != 0;  puts++)  UART2_TxByte(*puts);   //遇到停止符0结束
 144   1      }
 145          
 146          
 147          
 148          void  uart1_init(void)
 149          {
 150   1        PCON |= 0x80;   //UART0 Double Rate Enable
 151   1        SCON = 0x50;    //UART0 set as 10bit , UART0 RX enable
 152   1        TMOD &= ~(1<<6);    //Timer1 Set as Timer, 12T
 153   1        TMOD = (TMOD & ~0x30) | 0x20; //Timer1 set as 8 bits auto relaod
 154   1        TH1 = T1_TimerReload;   //Load the timer
 155   1        TR1  = 1;
 156   1        ES  = 1;
 157   1        EA = 1;
 158   1      }
 159          
 160          
 161          
 162          /**********************************************/
 163          void UART0_RCV (void) interrupt 4
 164          {
 165   1        if(RI)
 166   1        {
 167   2          RI = 0;
 168   2          RX1_Buffer[uart1_wr] = SBUF;
 169   2          if(++uart1_wr >= BUF_LENTH) uart1_wr = 0;
 170   2        }
 171   1      
 172   1        if(TI)
 173   1        {
 174   2          TI = 0;
 175   2          B_TI = 1;
 176   2        }
 177   1      }
C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 12:01:51 PAGE 4   

 178          
 179          
 180          /**********************************************/
 181          void  uart2_init(void)
 182          {
 183   1        AUXR |=  (1 << 3);    //串口2波特率加倍
 184   1        S2CON  = (S2CON & 0x3f) | (1<<6); //串口2模式1，8位UART，(2^S2SMOD / 32) * BRT溢出率
 185   1        S2CON |= 1 << 4;    //允许串2接收
 186   1      
 187   1        AUXR |=  1 << 4;  //baudrate use BRT
 188   1        BRT = BRT_Reload;
 189   1      
 190   1        IE2 |=  1;      //允许串口2中断
 191   1      }
 192          
 193          /**********************************************/
 194          void UART2_RCV (void) interrupt 8
 195          {
 196   1        if(RI2)
 197   1        {
 198   2          CLR_RI2();
 199   2          RX2_Buffer[uart2_wr] = S2BUF;
 200   2          if(++uart2_wr >= BUF_LENTH) uart2_wr = 0;
 201   2        }
 202   1      
 203   1        if(TI2)
 204   1        {
 205   2          CLR_TI2();
 206   2          B_TI2 = 1;
 207   2        }
 208   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    335    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =    256    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
