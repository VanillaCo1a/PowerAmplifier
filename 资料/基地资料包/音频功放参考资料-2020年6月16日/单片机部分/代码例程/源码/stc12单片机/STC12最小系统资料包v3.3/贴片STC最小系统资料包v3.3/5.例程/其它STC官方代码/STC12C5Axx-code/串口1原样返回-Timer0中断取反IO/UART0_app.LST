C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 11:50:54 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART0_APP
OBJECT MODULE PLACED IN UART0_app.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE UART0_app.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND
                    - TABS(2)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU RC Demo -----------------------------------*/
   5          /* --- Mobile: (86)13922805190 -------------------------------------*/
   6          /* --- Fax: 86-755-82944243 ----------------------------------------*/
   7          /* --- Tel: 86-755-82948412 ----------------------------------------*/
   8          /* --- Web: www.STCMCU.com -----------------------------------------*/
   9          /* If you want to use the program or the program referenced in the  */
  10          /* article, please specify in which data and procedures from STC    */
  11          /*------------------------------------------------------------------*/
  12          
  13          /*
  14            测试方法：
  15            根据您的主时钟和波特率修改下面的相关定义，编译后下载到MCU。
  16            通过串口助手向MCU发送数据，MCU收到后原样返回。
  17            Timer0中断测试, 取反一个IO输出。
  18          */
  19          
  20          #include  <reg51.h>
  21          #include  <math.h>
  22          #include  <stdlib.h>
  23          
  24          sfr AUXR  = 0x8E;
  25          sfr BRT   = 0x9C;
  26          
  27          #define   BUF_LENTH 128   //定义串口接收缓冲长度
  28          unsigned char   uart0_wr;   //写指针
  29          unsigned char   uart0_rd;   //读指针
  30          unsigned char   xdata RX0_Buffer[BUF_LENTH];
  31          bit   B_TI;
  32          
  33          sbit  P_PULSE = P1^0;   //Timer0中断取反一个IO输出方波.
  34          
  35          
  36          /*************** 用户定义参数 *****************************/
  37          
  38          //#define MAIN_Fosc   22118400L //define main clock
  39          #define MAIN_Fosc   11059200L //define main clock
  40          //#define MAIN_Fosc   18432000L //define main clock
  41          
  42          #define Baudrate0   9600    //define the baudrate,
  43                            //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  44          
  45          #define Timer0_Devide 12      //  Timer0分频系数，1: 1T,  12: 12T
  46          #define D_TIMER0    10000   //  选择定时器时间，限制最小25us
  47          
  48          /**********************************************************/
  49          
  50          
  51          /****************** 编译器自动处理，用户请勿修改 ************************************/
  52          
  53          #define T1_TimerReload  (256 - MAIN_Fosc / 192 / Baudrate0)     //Calculate the timer1 reload value at 12T mo
             -de
C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 11:50:54 PAGE 2   

  54          
  55          #if (D_TIMER0 >= 25)
  56            #define Timer0_CLK      (MAIN_Fosc / 100 / Timer0_Devide)
  57            #define Timer0_CNT      (D_TIMER0 * Timer0_CLK / 10000)
  58            #if (Timer0_CNT >= 65536)
                  #define Timer0_Reload 65535
                #else
  61              #define Timer0_Reload Timer0_CNT
  62            #endif
  63          #endif
  64          
  65          /**********************************************************/
  66          
  67          
  68          
  69          /******************** 本地函数声明 ***************/
  70          void  uart0_init(void);
  71          void  Timer0_init(void);
  72          
  73          
  74          
  75          void UART0_TxByte(unsigned char dat)
  76          {
  77   1        B_TI = 0;
  78   1        SBUF = dat;
  79   1        while(!B_TI)  ;
  80   1        B_TI = 0;
  81   1      }
  82          
  83          void  main(void)
  84          {
  85   1      
  86   1        Timer0_init();
  87   1        uart0_init();
  88   1        
  89   1      //  AUXR1 |= 0x80;    //UART0 switch to P1.7 P1.6
  90   1      
  91   1        while(1)
  92   1        {
  93   2          if(uart0_rd != uart0_wr)  //串口0转发
  94   2          {
  95   3            UART0_TxByte(RX0_Buffer[uart0_rd]);
  96   3            if(++uart0_rd >= BUF_LENTH)   uart0_rd = 0;
  97   3          }
  98   2        }
  99   1      }
 100          
 101          
 102          //========================================================================
 103          // 函数: void Timer0_init(void)
 104          // 描述: 初始化Timer0。
 105          // 参数: none.
 106          // 返回: none.
 107          // 版本: VER1.0
 108          // 日期: 2010-12-15
 109          // 备注: 
 110          //========================================================================
 111          
 112          void  Timer0_init(void)
 113          {
 114   1        #if (Timer0_Devide == 1)
                  AUXR |= (1 << 7); //1T mode
C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 11:50:54 PAGE 3   

                #endif
 117   1      
 118   1        #if (Timer0_Reload >= 256)
 119   1          TMOD = (TMOD & ~0x03) | 0x01;   //Timer0设置成16位
 120   1          TH0  = (65536-Timer0_Reload) / 256; //Timer0 16 bits
 121   1          TL0  = (65536-Timer0_Reload) % 256;
 122   1        #else
                  TMOD = (TMOD & ~0x03) | 0x02;   //Timer0设置成8位自动重装
                  TH0  = 256 - Timer0_Reload;   //Timer0 8 bits auto re-load
                #endif
 126   1      
 127   1        ET0 = 1;      //允许T0中断
 128   1        TR0 = 1;      //启动T0
 129   1        EA  = 1;      //允许全局中断
 130   1      }
 131          
 132          
 133          
 134          //========================================================================
 135          // 函数: void timer0 (void) interrupt 1
 136          // 描述: Timer0中断函数。
 137          // 参数: none.
 138          // 返回: none.
 139          // 版本: VER1.0
 140          // 日期: 2010-12-15
 141          // 备注: 
 142          //========================================================================
 143          void timer0 (void) interrupt 1
 144          {
 145   1        #if (Timer0_Reload >= 256)
 146   1          TR0 = 0;
 147   1          TH0  = (65536-Timer0_Reload) / 256; //Timer0 16 bits
 148   1          TL0  = (65536-Timer0_Reload) % 256;
 149   1          TR0 = 1;
 150   1        #endif
 151   1      
 152   1        P_PULSE = ~P_PULSE;
 153   1      }
 154          
 155          /*************** UART0 init ***************/
 156          void  uart0_init(void)
 157          {
 158   1        PCON |= 0x80;   //UART0 Double Rate Enable
 159   1        SCON = 0x50;    //UART0 set as 10bit , UART0 RX enable
 160   1        TMOD &= ~(1<<6);    //Timer1 Set as Timer, 12T
 161   1        TMOD = (TMOD & ~0x30) | 0x20; //Timer1 set as 8 bits auto relaod
 162   1        TH1 = T1_TimerReload;   //Load the timer
 163   1        TR1  = 1;
 164   1        ES  = 1;
 165   1      }
 166          
 167          
 168          /**********************************************/
 169          void UART0_RCV (void) interrupt 4
 170          {
 171   1        if(RI)
 172   1        {
 173   2          RI = 0;
 174   2          RX0_Buffer[uart0_wr] = SBUF;
 175   2          if(++uart0_wr >= BUF_LENTH) uart0_wr = 0;
 176   2        }
 177   1      
C51 COMPILER V9.54   UART0_APP                                                             04/27/2019 11:50:54 PAGE 4   

 178   1        if(TI)
 179   1        {
 180   2          TI = 0;
 181   2          B_TI = 1;
 182   2        }
 183   1      }
 184          
 185          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    166    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
